---
format: 
  pdf:
    fig-pos: "H"
    tbl-cap-location: bottom
lang: es
echo: FALSE
# eval: FALSE
message: FALSE
warning: FALSE
geometry:
  - top= 25mm
  - left= 20mm
  - right = 20mm
  - bottom = 25mm
  - heightrounded
header-includes:
  - \usepackage{ragged2e}
  - \usepackage{hyperref}
  - \usepackage{float}
  - \floatplacement{table}{H}
---


```{r Carga de librerias y funciones}
library(tidyverse)
library(patchwork)
library(tinytable)
library(rstan)
library(ggforce)
library(tidybayes) # No se que hace
library(bayesplot)
```

```{r Configuraciones predeterminadas}
knitr::opts_chunk$set(fig.align = "center", out.width = "70%")

set.seed("2126519")

theme_set(theme_bw())
```

::: {.center data-latex=""}

\vspace{3cm}

```{r logo facultad, echo=F, include = T, out.width= "60%"}
# knitr::include_graphics("logounr.png")
```

\pagenumbering{gobble}

\vspace{5cm}

\Large
**LICENCIATURA EN ESTADÍSTICA**

\vspace{1cm}

\Large
**UNA MASACRE ESTADÍSTICA**


\vspace{0.3cm}
\large

*Regresión Lineal Bayesiana*

\vspace{9cm}

\large

**Autores: Franco Santini - Nicolas Gamboa - Andrés Roncaglia**

**Docentes: Ignacio Evangelista - Tomás Capretto**

**2024**
\normalsize
\newpage
\hypersetup{linkcolor = black}
\tableofcontents


\newpage
\pagenumbering{arabic}

:::

\newpage



# Introducción

Siguiendo los acontecimientos de la muerte de sergio, una templada madrugada de miércoles en Salsipuedes, la policía forense busca determinar a qué hora murió. El encargado de esto es Guido, un estudiante de estadística fascinado por poder al fin aplicar sus conocimientos estadísticos en un caso de criminalística.

Los datos que la policía foresense propició a Guido son los siguientes:

```{mermaid}
timeline
    title Acontecimientos del día del crimen
    05.33hs : Llamado de Lidia Benegas al 911
    05.52hs : Llega el móvil policial a la escena. Sergio es encontrado en el suelo sobre un charco de sangre
    06.45hs : La policía científica determinó que sergio había fallecido, y presentaba una temperatura corporal de 32.8°C
    08.15hs : El cuerpo de Sergio es colocado en la bolsa de óbito para trasladarlo a la morgue. Su temperatura es de 30.5°C
    09.55hs : El cuerpo llega a la morgue
    13.30hs : Comienza la autopsia, la temperatura del cadaver es de 23.7°C
    16.10hs : Finaliza la autopsia. Se determina que Sergio falleció desangrado producto de una herida punzante en el brazo.
```

# Metodología

En la medicina forense existen muchas maneras de estimar la hora de la muerte. Entre ellas, una de las más utilizadas es el estudio de la temperatura corporal, la cual es posible estimar.

Se sabe que la temperatura del cuerpo de Sergio satisface la siguiente ley:

$$
\frac{d T(t)}{d t} = r[T_{amb}-T(t)]
$$
Donde $T_amb$ es la temperatura ambiente en donde se encuentra el cuerpo, en este caso 22°C, $r$ es una constante que determina el ritmo de enfriamiento y $T(t)$ es la función que describe la temperatura del cadaver en función del tiempo después de la muerte.

Una posible función $T(t)$ que satisface esta ecuación diferencial es la siguiente:


$$
T(t) = T_{\text{amb}} + (T_i - T_{\text{amb}})e^{-rt} \Rightarrow \\ 
\Rightarrow \frac{d T(t)}{d t} = -r(T_i - T_{\text{amb}}) \cdot e^{-rt} \\
r(T_{\text{amb}} - T_{\text{amb}})\cdot e^{-rt} - r(T_i - T_{\text{amb}}) \cdot e^{-rt} = \\ 
= r \{T_{\text{amb}} - T_{\text{amb}} - (T_i - T_{\text{amb}})e^{-rt} \} = \\ 
r \{T_{\text{amb}} - \underbrace{[T_{\text{amb}} + (T_i - T_{\text{amb}})e^{-rt}]}_{T(t)} \} = r [T_{\text{amb}} - T(t)]
$$

Algunos valores posibles para la constante de enfriamiento r son:


```{r}
function_T <- function(t, t_amb, t_ini, r) {
 
  # t: Tiempo en horas
  # t_amb: Temperatura ambiente
  # t_ini: Temperatura inicial del cuerpo
  # r: Constante
   
  if (any(t < 0)) {stop("El tiempo no puede ser negativo")}
  
  t_amb + (t_ini - t_amb)*exp(-r*t)
  
}

# Suponiendo un delta con media de 2 horas 15 minutos 
# y un desvío estandar de 20 minutos(A los sumo puede variar 1 hora mas o menos)
r1 <- function_T(t = seq(0,60, length.out = 1000),
           t_amb = 23,
           t_ini = 37,
           r = .3)

# r2 <- function_T(t = seq(0,60, length.out = 1000),
#            t_amb = 22,
#            t_ini = 37,
#            r = 0.2)

r2 <- function_T(t = seq(0,60, length.out = 1000),
           t_amb = 23,
           t_ini = 37,
           r = .1)
# r5 <- function_T(t = seq(0,60, length.out = 1000),
#            t_amb = 22,
#            t_ini = 37,
#            r = 0.16)
```


```{r}
#| fig-cap: "Temperatura del cuerpo según tiempo post-mortem\nTemperatura ambiente: 23°C"
#| 
#| 


data.frame(t = rep(seq(0,60, length.out = 1000), times = 2),
           obs = c(r1,r2),
           valor_r = rep(c("0.1","0.3"), each = 1000)) |> 
  ggplot() + 
  geom_line(aes(x = t, y = obs, color = valor_r)) +
  scale_y_continuous(breaks = seq(23,37,by=2), limits = c(23,37)) +
  scale_x_continuous(breaks = seq(0,24,by=2), limits = c(0,24)) +
  labs(x = "Tiempo (horas)", color = "r", y = "Temperatura corporal (ºC)")


```

Al ser su primer caso oficial, Guido se sintió un poco desconcertado por no saber a qué hora podría haber ocurrido la tragedia.

Según lo publicado por la [La Gaceta Internacional de Ciencias Forenses](https://www.uv.es/gicf/3R1_Pen%CC%83a_GICF_31.pdf) la tasa de enfriamiento del cuerpo varía en tres estapas, las primeras 3 o 4 horas donde la temperatura baja menos de medio grado por hora, las siguientes 6 a 10 horas donde la temperatura baja alrededor de 1 grado por hora, y a partir de las 10 horas el cuerpo desciende su temperatura entre 3/4 a 1/4 grados por hora, hasta alcanzar la temperatura ambiente. Teniendo en cuenta que r se supone constante, se puede asumir que un buen valor de r es mayor que 0,1 y menor que 0,45.

Con el objetivo de finalmente, después de tanto esfuerzo, estimar la hora de la muerte de Sergio, Guido decide utilizar un enfoque Bayesiano, planteando el siguiente modelo lineal.


  
$$
T(t) - T_{\text{amb}} = T_{\text{diff}} e^{-rt} \Rightarrow \\ ln(T(t) - T_{\text{amb}}) = ln(T_{\text{diff}} e^{-rt}) = \underbrace{ln(T_{\text{diff}})}_{\beta_0} - \underbrace{r}_{\beta_1}t = \beta_0 + \beta_1 \cdot t
$$

Donde $\beta_0$ representa el logaritmo natural de la diferencia entre la temperatura inicial del cuerpo y la temperatura ambiente y $\beta_1$ es el cambio esperado en la diferencia de temperaturas del logaritmo por cada hora.


Una transformación posible para este modelo es la siguiente:

Para poder interpretar t como el tiempo después de haber encontrado el cuerpo, se realiza una traslación utilizando un nuevo parámetro $\delta$.

$$
T(t+\delta) - T_{\text{amb}} = T_{\text{diff}} e^{-r(t+\delta)} \Rightarrow \\ 
ln(T(t+\delta) - T_{\text{amb}}) = ln(T_{\text{diff}} e^{-r(t+\delta)}) = \\ 
\underbrace{ln(T_{\text{diff}})}_{\beta_0} - \underbrace{r}_{\beta_1}(t+\delta) = \beta_0 - \beta_1 \cdot (t+\delta)
$$
El modelo que se usa para estimar la hora de muerte de Sergio resulta entonces:

$$
ln(T(t+\delta) - T_{\text{amb}}) = \beta_0 - \beta_1 \cdot (t+\delta)
$$

Donde:

-   $\delta$ es el tiempo (en horas) que transcurrió entre la que persona murió y se encontró el cuerpo.

-   Los demás parámetros conservan su significado.

Guido recuerda haber mirado el pronóstico del tiempo el día de la muerte de Sergio y recuerda que anunciaban una temperatura ambiente de 22ºC. Por otro lado, dado que la temperatura corporal de una persona sana ronda los 37°C, consideró esta la temperatura inicial del cuerpo de Sergio. 


$$
ln(T(0)-T_{amb}) = \beta_0 - \beta_1 \cdot (0) \\
\beta_0 = ln(37-22) =ln(15)=  2.7081
$$

Al ser un enfoque bayesiano, Guido debe pensar una distribución a priori para los parámetros $\delta$ y $\beta_1$.

En principio, dado que el cuerpo fue encontrado con una temperatura corporal de 32.8°C, y sabiendo que Sergio murió desangrado, lo cual acelera considerablemente el descenso de la temperatura, cree que debe haber muerto hace aproximadamente 2 horas, aunque no está para nada seguro, por lo que utilizará una distribución uniforme, que irá entre 1 hora y media y 2 horas y media. 

Con respecto al parámetro $\beta_1$, y considerando la hora a la que estima que murió Sergio y la temperatura a la que fue encontrado, observa lo siguiente.


```{r}
r1 <- function_T(t = seq(0,60, length.out = 1000),
           t_amb = 22,
           t_ini = 37,
           r = 0.1375)

r2 <- function_T(t = seq(0,60, length.out = 1000),
           t_amb = 22,
           t_ini = 37,
           r = 0.16)

r4 <- function_T(t = seq(0,60, length.out = 1000),
           t_amb = 22,
           t_ini = 37,
           r = 0.1825)

```


```{r}
#| fig-cap: "Temperatura del cuerpo según tiempo post-mortem\nTemperatura ambiente: 22°C"
data.frame(t = rep(seq(0,60, length.out = 1000), times = 3),
           obs = c(r1,r2,r4),
           valor_r = rep(c("r = 0.14", "r = 0.16","r = 0.18"), each = 1000)) |> 
  ggplot() + 
  geom_line(aes(x = t, y = obs, color = valor_r)) +
  scale_y_continuous(breaks = seq(23,37,by=2), limits = c(23,37)) +
  scale_x_continuous(breaks = seq(0,10,by=0.5), limits = c(0,10)) +
  labs(x = "Tiempo (horas)", color = "r", y = "Temperatura corporal (ºC)")+
  geom_hline(yintercept = 32.8, linetype = "dashed")+
  # geom_vline(xintercept = 0.5) +
  geom_vline(xintercept = 2, linetype = "dashed")
```

En base a esto, tomará valores similares a los graficados para la distribución de $\beta_1$, considerando una distribución normal.

De manera un poco más formal, el modelo que planteado por Guido es el siguiente:

$$
ln(Y)/\mu_i,\ \sigma \sim N(\mu_i,\ \sigma) \\ 
\mu_i=\beta_0 + \beta_1\cdot (t+\delta) \\ 
\beta_0 =2.7081 \\ 
\beta_1 \sim N^+(0.16,\ 0.075) \\ 
\delta \sim U(1.5, \ 2.5) \\ 
\sigma \sim N^+(0,\ 0.2 )
$$

Los parámetros, a priori, son independientes y siguen las distribuciones mencionadas.

El interés se centra principalmente en el parámetro $\delta$

# Resultados

El objetivo de Guido es estimar la hora de la muerte y para hacerlo usará toda la información que tenga a su disposición. Pero antes de esto quiere confirmar que sus creencias iniciales tienen sentido, por lo que decide realizar pruebas predictivas a priori.

## Pruebas predictivas a priori

```{r}
load(file = "Stan_models/Resultados_modelos.RData")

datos <- data.frame(
  t = c(0,1.5, 6.75),
  diff = c(10.8,8.5, 1.7)
)

n <- 40000
largo_grilla <- 100

grilla_t <- seq(-4, 7 ,length.out = largo_grilla)

beta_0 <- 2.7081
pred_prior <- data.frame(
  prior_beta_1 = abs(rnorm(n, 0.16, 0.02)),
  prior_d = abs(runif(n, min = 1.5, max = 2.5)),
  prior_sigma = abs(rnorm(n,0,0.05))

  ) 


calc_diff_prom <- function(t, data) {
  return(beta_0 - data$prior_beta_1 * (t+data$prior_d))
}


diff_prom <- sapply(grilla_t, calc_diff_prom, pred_prior) |> `colnames<-`(round(grilla_t,1))

graf <- as.data.frame(diff_prom)

# Grafico con intervalo de credibilidad ------------


mu_mean <- apply(graf, 2, mean)

mu_qts <- t(apply(graf, 2, function(x) quantile(x, c(0.025, 0.975))))

mu_qts2 <- t(apply(graf, 2, function(x) quantile(x, c(0.25, 0.75))))


data_mu <- data.frame(
  t = grilla_t, 
  y = mu_mean,
  lower_95 = mu_qts[, 1],
  upper_95 = mu_qts[, 2],
  lower_50 = mu_qts2[, 1],
  upper_50 = mu_qts2[, 2]
)
```


```{r}
#| fig-cap: "Distribución a Priori del predictor lineal."

ggplot(data_mu) +
  geom_ribbon(
    aes(t, ymin = lower_95, ymax = upper_95),
    fill = "grey50",
    alpha = 0.6
  ) +
  geom_ribbon(
    aes(t, ymin = lower_50, ymax = upper_50),
    fill = "grey35",
    alpha = 0.6
  ) +
  geom_line(
    aes(t, y), 
    color = "firebrick"
  ) + 
  labs(x = "Tiempo", y = expression(mu[i])) +
  scale_x_continuous(breaks = seq(-4,7,1), limits = c(-4,7))
  

```

En un principio, el prior de Guido parece tener sentido.

Busca un intervalo de tiempo en el que pueda decir con 90% de certeza que Sergio murió dentro de ese rango horario.

```{r}

predictiva_prior <- quantile(pred_prior$prior_d,probs = c(0.05, 0.95))

# 1.55
# 2.44
```

A priori Guido concluye con una credibilidad del 90% que sergio murió entre las 4.19hs y las 5.12hs.


## Pruebas predictivas a Posteriori

Ahora sí, finalmente Guido utilizará los datos provistos para estimar la hora de la muerte, pero con el objetivo de desafiarse a sí mismo decide hacerlo de manera secuencial, para ver como los datos van afectando sus estimaciones.

Después de que la computadora de bajos recursos del departamento de la Policía Científica estuviera encendida durante días, Guido consiguió los siguientes resultados.

Los datos disponibles son los siguientes:

```{r}
datos |> 
  mutate(log_diff = round(log(diff), 3)) |> 
  `colnames<-`(c("$Tiempo$", "$Temp_{diff}$", "$ln(Temp_{diff})$")) |>
  knitr::kable(format = "pipe")
```


```{r prediccion 7am}
stan_data <- list(
    N = nrow(datos[1,]), 
    t = as.array(datos[1,]$t),     
    y = as.array(log(datos[1,]$diff))      
)

```


```{r, eval=FALSE}
stan_model <- stan(
    file = "Stan_models/Model_1.stan",
    chains = 4,
    data = stan_data,
    iter = 10000,
    refresh = 0,
    seed = 90502
    )
```

A Guido le remarcaban mucho en clases de Estadística Bayesiana la importancia de verificar la convergencia de las cadenas de Markov, en este caso obtenidas por el método NUTS (_No-U-Turn Sampler_), para los distintos párametros del modelo. Es por ello que para cada una de las estimaciones de los parámetros, presenta gráficos de densidad y de traza.

```{r}
mcmc_dens_overlay(stan_model)
mcmc_trace(stan_model)

df_posterior <- as.data.frame(extract(stan_model))

```

Con la información provista hasta las 7 de la mañana las cadenas de markov para cada uno de los parametros parecen converger a la misma distribucion a posteriori. Esto, además de haber obtenido un $\hat R = 1$ para todos los párametros le confirman a Guido que las muestras obtenidas son representativas de los parámetros.


La curiosidad de Guido lo llevaba a querer visualizar como los datos afectan al prior, por lo que graficó bandas de credibilidad para el predictor lineal y para la diferencias de temperaturas.

```{r}

calc_pred_linear <- function(t, data) {
  return((2.7081 - data$beta1 * (t+data$d)))
}

pred_linear <- sapply(grilla_t, calc_pred_linear, df_posterior) |> `colnames<-`(round(grilla_t,1))

pred_linear <- as.data.frame(pred_linear)



# Grafico con intervalo de credibilidad ------------


mu_mean <- apply(pred_linear, 2, mean)

mu_qts <- t(apply(pred_linear, 2, function(x) quantile(x, c(0.025, 0.975))))

mu_qts2 <- t(apply(pred_linear, 2, function(x) quantile(x, c(0.25, 0.75))))


data_mu <- data.frame(
  t = grilla_t, 
  y = mu_mean,
  lower_95 = mu_qts[, 1],
  upper_95 = mu_qts[, 2],
  lower_50 = mu_qts2[, 1],
  upper_50 = mu_qts2[, 2]
)
```


```{r prediccion 7am 2}
# Bandas

calc_diff_prom_posterior <- function(t, data) {
  return(exp(rnorm(nrow(data), mean = (2.7081 - data$beta1 * (t+data$d)), sd = data$sigma)))
}

diff_prom_2 <- sapply(grilla_t, calc_diff_prom_posterior, df_posterior) |> `colnames<-`(round(grilla_t,1))

graf_2 <- as.data.frame(diff_prom_2)



# Grafico con intervalo de credibilidad ------------


y_mean <- apply(graf_2, 2, mean)

y_qts <- t(apply(graf_2, 2, function(x) quantile(x, c(0.025, 0.975))))

y_qts2 <- t(apply(graf_2, 2, function(x) quantile(x, c(0.25, 0.75))))


data_y <- data.frame(
  t = grilla_t, 
  y = y_mean,
  lower_95 = y_qts[, 1],
  upper_95 = y_qts[, 2],
  lower_50 = y_qts2[, 1],
  upper_50 = y_qts2[, 2]
)
```


```{r graf prediccion 7am 2}
#| fig-cap: "Distribuciónes a Priori con la información hasta las 7hs."
#| fig-subcap: 
#|   - "Del predictor lineal"
#|   - "De $T(t)-T_{amb}$"
#| layout-ncol: 2

ggplot(data_mu) +
  geom_ribbon(
    aes(t, ymin = lower_95, ymax = upper_95),
    fill = "grey50",
    alpha = 0.6) +
  geom_ribbon(
    aes(t, ymin = lower_50, ymax = upper_50),
    fill = "grey35",
    alpha = 0.6) +
  geom_line(
    aes(t, y), 
    color = "firebrick") + 
  geom_point(
    data = datos[1,],mapping = aes(x = t, y = log(diff)), size = 1) +
  # geom_mark_ellipse(
  #   data = datos[1,],
  #   mapping = aes(x = t, y = log(diff)),
  #   label = "Primera observación",
  #   description = "06:45 | 32.8ºC", 
  #   color = "red", 
  #   expand = 0.01) +
  labs(x = "Tiempo", y = expression(mu[i])) +
  scale_x_continuous(breaks = seq(-4,7,1), limits = c(-4,7))


ggplot(data_y) +
  geom_ribbon(
    aes(t, ymin = lower_95, ymax = upper_95),
    fill = "grey50",
    alpha = 0.6) +
  geom_ribbon(
    aes(t, ymin = lower_50, ymax = upper_50),
    fill = "grey35",
    alpha = 0.6) +
  geom_line(
    aes(t, y), 
    color = "firebrick") + 
  # geom_mark_ellipse(
  #   data = datos[1,],
  #   mapping = aes(x = t, y = log(diff)),
  #   label = "Primera observación",
  #   description = "06:45 | 32.8ºC", 
  #   color = "red", 
  #   expand = 0.01) +
  labs(x = "Tiempo", y = expression(T(t)-T[amb])) +
  scale_x_continuous(breaks = seq(-4,7,1), limits = c(-4,7))



```

```{r}
predictiva_post1 <- quantile(df_posterior$d,probs = c(0.05, 0.95))
```


Guido observa que esta primera observación parece acotar levemente el intervalo de tiempo en el que puede decir con una buena certeza que Sergio murió. Ahora Guido puede decir con la misma credibilidad de antes que Sergio falleció entre las 4:19hs y las 5:11hs. Esto no parece mucho, pero le sirve a Guido para saber que va por buen camino, lo cual lo motiva a seguir.

Guido procede a seguir añadiendo datos a su modelo, con lo que usa la información disponible hasta las 10hs obteniendo los siguientes resultados. 

```{r prediccion 10am 1, eval=FALSE}
stan_data_2 <- list(
    N = nrow(datos[1:2,]), 
    t = datos[1:2,]$t,     
    y = log(datos[1:2,]$diff)      
)

stan_model_2 <- stan(
    file = "Stan_models/Model_1.stan",
    chains = 4,
    data = stan_data_2,
    iter = 10000,
    refresh = 0,
    seed = 110701
)
```


```{r}
mcmc_trace(stan_model_2)
mcmc_dens_overlay(stan_model_2)

df_posterior_2 <- as.data.frame(extract(stan_model_2))

```

De igual forma que con un solo dato, las cadenas convergen a la misma distribución para todos los parámetros, pero estas son incluso más acotadas que antes.

```{r prediccion 10am 2}
# Grafico con intervalo de credibilidad

pred_linear2 <- sapply(grilla_t, calc_pred_linear, df_posterior_2) |> `colnames<-`(round(grilla_t,1))

pred_linear2 <- as.data.frame(pred_linear2)



mu_mean <- apply(pred_linear2, 2, mean)

mu_qts <- t(apply(pred_linear2, 2, function(x) quantile(x, c(0.025, 0.975))))

mu_qts2 <- t(apply(pred_linear2, 2, function(x) quantile(x, c(0.25, 0.75))))


data_mu2 <- data.frame(
  t = grilla_t, 
  y = mu_mean,
  lower_95 = mu_qts[, 1],
  upper_95 = mu_qts[, 2],
  lower_50 = mu_qts2[, 1],
  upper_50 = mu_qts2[, 2]
)

# Grafico con intervalo de credibilidad

diff_prom_3 <- sapply(grilla_t, calc_diff_prom_posterior, df_posterior_2) |> `colnames<-`(round(grilla_t,1))

graf_3 <- as.data.frame(diff_prom_3)



y_mean <- apply(graf_3, 2, mean)

y_qts <- t(apply(graf_3, 2, function(x) quantile(x, c(0.025, 0.975))))

y_qts2 <- t(apply(graf_3, 2, function(x) quantile(x, c(0.25, 0.75))))


data_y2 <- data.frame(
  t = grilla_t, 
  y = y_mean,
  lower_95 = y_qts[, 1],
  upper_95 = y_qts[, 2],
  lower_50 = y_qts2[, 1],
  upper_50 = y_qts2[, 2]
)


```


```{r}
#| fig-cap: "Distribuciónes a Priori con la información hasta las 7hs."
#| fig-subcap: 
#|   - "Del predictor lineal"
#|   - "De $T(t)-T_{amb}$"
#| layout-ncol: 2

ggplot(data_mu2) +
  geom_ribbon(
    aes(t, ymin = lower_95, ymax = upper_95),
    fill = "grey50",
    alpha = 0.6) +
  geom_ribbon(
    aes(t, ymin = lower_50, ymax = upper_50),
    fill = "grey35",
    alpha = 0.6) +
  geom_line(
    aes(t, y), 
    color = "firebrick") + 
  geom_point(
    data = datos[1:2,],mapping = aes(x = t, y = log(diff)), size = 1) +
  # geom_mark_ellipse(
  #   data = datos[1,],
  #   mapping = aes(x = t, y = log(diff)),
  #   label = "Primera observación",
  #   description = "06:45 | 32.8ºC", 
  #   color = "red", 
  #   expand = 0.01) +
  labs(x = "Tiempo", y = expression(mu[i])) +
  scale_x_continuous(breaks = seq(-4,7,1), limits = c(-4,7))


ggplot(data_y2) +
  geom_ribbon(
    aes(t, ymin = lower_95, ymax = upper_95),
    fill = "grey50",
    alpha = 0.6) +
  geom_ribbon(
    aes(t, ymin = lower_50, ymax = upper_50),
    fill = "grey35",
    alpha = 0.6) +
  geom_line(
    aes(t, y), 
    color = "firebrick") + 
  # geom_mark_ellipse(
  #   data = datos[1,],
  #   mapping = aes(x = t, y = log(diff)),
  #   label = "Primera observación",
  #   description = "06:45 | 32.8ºC", 
  #   color = "red", 
  #   expand = 0.01) +
  labs(x = "Tiempo", y = expression(T(t)-T[amb])) +
  scale_x_continuous(breaks = seq(-4,7,1), limits = c(-4,7))

```

```{r}
predictiva_post2 <- quantile(df_posterior_2$d,probs = c(0.05, 0.95))
```


Guido ahora concluye con una certeza del 90% que Sergio pereció entre las 4:20hs y las 5:07hs.

Finalmente, decide hacer uso de toda la información disponible, aunque la última temperatura registrada del cuerpo le traía un mal presentimiento...

```{r prediccion todos los datos 1}
stan_data_3 <- list(
    N = nrow(datos), 
    t = datos$t,     
    y = log(datos$diff)      
)
```

```{r, eval=FALSE}
stan_model_3 <- stan(
    file = "Stan_models/Model_1.stan",
    chains = 4,
    data = stan_data_3,
    iter = 10000,
    refresh = 0,
    seed = 90502
)
# save(stan_model,stan_model_2,stan_model_3,file = "Stan_models/Resultados_modelos.RData")
```


```{r}
mcmc_dens_overlay(stan_model_3)

mcmc_trace(stan_model_3)

df_posterior_3 <- as.data.frame(extract(stan_model_3))

```

Hasta ahora todo iba bien, las cadenas aún convergían, pero al ver la densidad estimada del parámetro $\delta$ sospechaba que algo no encajaba, pero decidió seguir adelante.

```{r prediccion 10am 3}
# Grafico con intervalo de credibilidad

pred_linear3 <- sapply(grilla_t, calc_pred_linear, df_posterior_3) |> `colnames<-`(round(grilla_t,1))

pred_linear3 <- as.data.frame(pred_linear3)



mu_mean <- apply(pred_linear3, 2, mean)

mu_qts <- t(apply(pred_linear3, 2, function(x) quantile(x, c(0.025, 0.975))))

mu_qts2 <- t(apply(pred_linear3, 2, function(x) quantile(x, c(0.25, 0.75))))


data_mu3 <- data.frame(
  t = grilla_t, 
  y = mu_mean,
  lower_95 = mu_qts[, 1],
  upper_95 = mu_qts[, 2],
  lower_50 = mu_qts2[, 1],
  upper_50 = mu_qts2[, 2]
)

# Grafico con intervalo de credibilidad

diff_prom_4 <- sapply(grilla_t, calc_diff_prom_posterior, df_posterior_3) |> `colnames<-`(round(grilla_t,1))

graf_4 <- as.data.frame(diff_prom_4)



y_mean <- apply(graf_4, 2, mean)

y_qts <- t(apply(graf_4, 2, function(x) quantile(x, c(0.025, 0.975))))

y_qts2 <- t(apply(graf_4, 2, function(x) quantile(x, c(0.25, 0.75))))


data_y3 <- data.frame(
  t = grilla_t, 
  y = y_mean,
  lower_95 = y_qts[, 1],
  upper_95 = y_qts[, 2],
  lower_50 = y_qts2[, 1],
  upper_50 = y_qts2[, 2]
)


```


```{r}
#| fig-cap: "Distribuciónes a Priori con la información hasta las 7hs."
#| fig-subcap: 
#|   - "Del predictor lineal"
#|   - "De $T(t)-T_{amb}$"
#| layout-ncol: 2

ggplot(data_mu3) +
  geom_ribbon(
    aes(t, ymin = lower_95, ymax = upper_95),
    fill = "grey50",
    alpha = 0.6) +
  geom_ribbon(
    aes(t, ymin = lower_50, ymax = upper_50),
    fill = "grey35",
    alpha = 0.6) +
  geom_line(
    aes(t, y), 
    color = "firebrick") + 
  geom_point(
    data = datos,mapping = aes(x = t, y = log(diff)), size = 1) +
  # geom_mark_ellipse(
  #   data = datos[1,],
  #   mapping = aes(x = t, y = log(diff)),
  #   label = "Primera observación",
  #   description = "06:45 | 32.8ºC", 
  #   color = "red", 
  #   expand = 0.01) +
  labs(x = "Tiempo", y = expression(mu[i])) +
  scale_x_continuous(breaks = seq(-4,7,1), limits = c(-4,7))


ggplot(data_y3) +
  geom_ribbon(
    aes(t, ymin = lower_95, ymax = upper_95),
    fill = "grey50",
    alpha = 0.6) +
  geom_ribbon(
    aes(t, ymin = lower_50, ymax = upper_50),
    fill = "grey35",
    alpha = 0.6) +
  geom_line(
    aes(t, y), 
    color = "firebrick") + 
  # geom_mark_ellipse(
  #   data = datos[1,],
  #   mapping = aes(x = t, y = log(diff)),
  #   label = "Primera observación",
  #   description = "06:45 | 32.8ºC", 
  #   color = "red", 
  #   expand = 0.01) +
  labs(x = "Tiempo", y = expression(T(t)-T[amb])) +
  scale_x_continuous(breaks = seq(-4,7,1), limits = c(-4,7))

```

```{r}
predictiva_post3 <- quantile(x = df_posterior_3$d,probs = c(0.05, 0.95))
```

Con estos resultados, Sergio pudo haber fenecido entre las 4:17hs y las 5:10hs, un intervalo de tiempo mayor que el que se había obtenido anteriormente.

"¡Lo que sospechaba!" dijo Guido, al asimilar que la última temperatura registrada de Sergio fue en la morgue, un lugar que tiende a ser frío para la preservación de los cadáveres, con lo que la temperatura del cuerpo de Sergio pudo haberse enfriado más rapidamente que en el lugar del hecho, donde recuerda que había una temperatura ambiente de 22ºC.

# Punto 9

Modificaría algún aspecto del modelo si supiera que Sergio no gozaba de buena salud al momento de fallecer?.

Si se tuviese información que indique que Sergio no gozaba de buena salud al momento de fallecer esto podría modificar nuestra creencia a Priori ya que la velocidad de enfriamiento se retarda en casos de enfermedades febriles, intoxicaciones por nicotina, rodenticidas, entre otros y obesidad. También la perdida de calor del cuerpo puede acelerarse en personas con bajo peso, enfermedades crónicas e intoxicadas por fósforo, arsénico y alcohol.

Una posible solución podría ser una variable que indique la enfermedad.

Se podría entonces agregar una nueva variable que indique como se modifica la tasa de enfriamiento del cuerpo según su estado de salud previo a la muerte. Resultando el modelo:

$\underbrace{ln(T_{\text{diff}})}_{\beta_0} + \underbrace{(-r)}_{\beta_1}t + (\alpha)t= \beta_0 + \beta_1 \cdot t + \beta_2 \cdot t$


No modificaría en ningún aspecto el modelo el saber que Sergio no gozaba de buena salud, dado que nuestro prior abarca hasta el caso más extremo de la temperatura corporal de una persona, considerando que la temperatura del ambiente se encuentra a 22°.


# COSAS A AGREGAR

- Interpretaciones a los gráficos de las bandas de credibilidad

- Graficos de trazas y densidades de parametros

- Revisar la redaccion del principio

- Linea de tiempo con el paquete ggtimelines

