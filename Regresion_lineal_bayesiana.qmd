---
format: 
  pdf:
    fig-pos: "H"
    tbl-cap-location: bottom
lang: es
echo: FALSE
# eval: FALSE
message: FALSE
warning: FALSE
geometry:
  - top= 25mm
  - left= 20mm
  - right = 20mm
  - bottom = 25mm
  - heightrounded
header-includes:
  - \usepackage{ragged2e}
  - \usepackage{hyperref}
  - \usepackage{float}
  - \floatplacement{table}{H}
---


```{r Carga de librerias y funciones}
library(tidyverse)
library(patchwork)
library(tinytable)
library(rstan)
library(ggforce)
library(bayesplot)
library(lubridate)
library(stringr)
library(ggfittext)
```

```{r Configuraciones predeterminadas}
knitr::opts_chunk$set(fig.align = "center", out.width = "70%")

set.seed("2126519")

theme_set(theme_bw())
```

::: {.center data-latex=""}

\vspace{3cm}

```{r logo facultad, echo=F, include = T, out.width= "60%"}
knitr::include_graphics("logounr.png")
```

\pagenumbering{gobble}

\vspace{5cm}

\Large
**LICENCIATURA EN ESTADÍSTICA**

\vspace{1cm}

\Large
**UNA MASACRE ESTADÍSTICA**


\vspace{0.3cm}
\large

*Regresión Lineal Bayesiana*

\vspace{8cm}

\large

**Autores: Franco Santini - Nicolas Gamboa - Andrés Roncaglia**

**Docentes: Ignacio Evangelista - Tomás Capretto**

**2024**
\normalsize
\newpage
\hypersetup{linkcolor = black}
\tableofcontents


\newpage
\pagenumbering{arabic}

:::

\newpage

```{r funcion hora}
# Función para calcular la hora
dec_a_hex <- function(x){
    hora <- trunc(x)
    minutos <- round((x-hora)*60,digits = 0)
    hora <- ifelse(hora<10,paste0("0",hora), hora)
    minutos <- ifelse(minutos<10, paste0("0",minutos), minutos)
    return(paste0(hora,":",minutos,"hs"))
}
```

# Introducción

Siguiendo los acontecimientos de la muerte de Sergio, una templada madrugada de miércoles en Salsipuedes, la policía forense busca determinar la hora de su muerte. El encargado de esto es Guido, un estudiante de estadística fascinado por poder al fin aplicar sus conocimientos estadísticos en un caso de criminalística.

Los datos que la policía foresense propició a Guido son los siguientes:

```{r}
data <- data.frame(date = hm(c("05:33", "05 52", "06 45", "08 15", "09 55", "13 30", "16 10")),
                   event = c("Llamado de Lidia Benegas al 911", "Llega el móvil policial a la escena. Sergio es encontrado en el suelo sobre un charco de sangre", "La policía científica determinó que Sergio había fallecido, y presentaba una temperatura corporal de 32.8°C", "El cuerpo de Sergio es colocado en la bolsa de óbito para trasladarlo a la morgue. Su temperatura es de 30.5°C", "El cuerpo llega a la morgue", "Comienza la autopsia, la temperatura del cadaver es de 23.7°C", "Finaliza la autopsia. Se determina que Sergio falleció desangrado producto de una herida punzante en el bazo"))

datos <- data |>
  arrange(by = date) |> 
  mutate(date_chr = format(parse_date_time(date, c('HMS', 'HM')), "%H:%M"),
         date = parse_date_time(date, c('HM', 'HMS')),
         time = abs(as.numeric(date-date[nrow(data)])),
         lines = case_when(nrow(data) > 4 ~ rep(c(2,2,5,5), length.out = nrow(data)) * rep(c(1,-1), length.out = nrow(data)),
                           T ~ 3),
         event_u = ifelse(lines > 0, event, ""),
         event_l = ifelse(lines < 0, event, ""))


text_sep = 1
time_sep = 0.7
title_size = 8
title = "Acontecimientos del día del crimen"
begin = format(datos$date[1]-max(datos$time)*0.1, "%H:%M")
end = format(datos$date[nrow(datos)]+max(datos$time)*0.1, "%H:%M")
adjusted_positions <- datos$lines + sign(datos$lines) * (2.5+text_sep)
```


```{r, eval=FALSE}
timeline <- ggplot(datos) + 
  # Base
  geom_segment(aes(y = 0-max(time)*0.1, yend = max(time)+max(time)*0.1, x = 0, xend = 0)) + # Linea central
  geom_segment(aes(y = 0-max(time)*0.1, yend = 0-max(time)*0.1, x = -0.2, xend = 0.2)) + # Linea base
  geom_segment(aes(y = max(time)+max(time)*0.1, yend = max(time)+max(time)*0.1, x = -0.2, xend = 0.2)) + # Linea tope
  annotate(geom = "text", label = begin, x = 0, y = max(datos$time)+max(datos$time)*0.15) + # Fecha inicial
  annotate(geom = "text", label = end, x = 0, y = 0-max(datos$time)*0.15) + # Fecha final
  # Titulo
  annotate(geom = "label", label = title, x = 10, y = max(datos$time)/2,#y = max(datos$time)+max(datos$time)*0.25,
           fontface = "bold", size = title_size) +
  # Eventos
  geom_segment(aes(y = time, yend = time, x = 0, xend = lines), linetype ="dashed") + # Linea del evento
  geom_point(aes(y = time, x = lines), color = "firebrick3") + # Punto del evento
  annotate(geom = "text", label = datos$date_chr, x = datos$lines, y = datos$time+max(datos$time)*time_sep*0.05) + # Tiempo del evento
  geom_fit_text(aes(x = adjusted_positions, y = time, label = event_u),
                reflow = TRUE, width = unit(5, "cm"), height = unit(5, "cm"), place = "bottom") +
  geom_fit_text(aes(x = adjusted_positions, y = time, label = event_l),
                reflow = TRUE, width = unit(5, "cm"), height = unit(5, "cm"), place = "top") +
  # Escalas de los ejes
  scale_y_continuous(limits = c(0-max(datos$time)*0.2,max(datos$time)+max(datos$time)*0.3)) + 
  scale_x_continuous(limits = c(-10,10)) +
  # Elimino ciertas cosas del grafico
  theme_bw() +
  theme(
    plot.background = element_blank(),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(),
    panel.border = element_blank(),
    axis.title = element_blank(),
    axis.text = element_blank(),
    axis.ticks = element_blank()
  ) +
  coord_flip() +
  scale_y_reverse()

ggsave(filename = "timeline.png", width = 901*4, height = 783*3, units = "px")
```

![](timeline.png)

# Metodología

En la medicina forense existen muchas maneras de estimar la hora de la muerte. Entre ellas, una de las más utilizadas es el estudio de la temperatura corporal.

Se sabe que la temperatura de un cuerpo satisface la siguiente ley:

$$
\frac{d T(t)}{d t} = r[T_{amb}-T(t)]
$$
Donde $T_amb$ es la temperatura ambiente en donde se encuentra el cuerpo, en este caso 22 °C, $r$ es una constante que determina el ritmo de enfriamiento y $T(t)$ es la función que describe la temperatura del cadaver en función del tiempo después de la muerte.

Una posible función $T(t)$ que satisface esta ecuación diferencial es la siguiente:


$$
T(t) = T_{\text{amb}} + (T_i - T_{\text{amb}})e^{-rt} \Rightarrow \frac{d T(t)}{d t} = -r(T_i - T_{\text{amb}}) \cdot e^{-rt} \\ r(T_{\text{amb}} - T_{\text{amb}})\cdot e^{-rt} - r(T_i - T_{\text{amb}}) \cdot e^{-rt} = r \{T_{\text{amb}} - T_{\text{amb}} - (T_i - T_{\text{amb}})e^{-rt} \} = \\ = r \{T_{\text{amb}} - \underbrace{[T_{\text{amb}} + (T_i - T_{\text{amb}})e^{-rt}]}_{T(t)} \} = r [T_{\text{amb}} - T(t)]
$$


Algunos valores posibles para la constante de enfriamiento r son:


```{r}
function_T <- function(t, t_amb, t_ini, r) {
 
  # t: Tiempo en horas
  # t_amb: Temperatura ambiente
  # t_ini: Temperatura inicial del cuerpo
  # r: Constante
   
  if (any(t < 0)) {stop("El tiempo no puede ser negativo")}
  
  t_amb + (t_ini - t_amb)*exp(-r*t)
  
}

# Suponiendo un delta con media de 2 horas 15 minutos 
# y un desvío estandar de 20 minutos(A los sumo puede variar 1 hora mas o menos)
r1 <- function_T(t = seq(0,60, length.out = 1000),
           t_amb = 23,
           t_ini = 37,
           r = .3)

# r2 <- function_T(t = seq(0,60, length.out = 1000),
#            t_amb = 22,
#            t_ini = 37,
#            r = 0.2)

r2 <- function_T(t = seq(0,60, length.out = 1000),
           t_amb = 23,
           t_ini = 37,
           r = .1)
# r5 <- function_T(t = seq(0,60, length.out = 1000),
#            t_amb = 22,
#            t_ini = 37,
#            r = 0.16)
```


```{r}
#| fig-cap: "Temperatura del cuerpo según tiempo post-mortem\nTemperatura ambiente: 23 °C"
#| 
#| 


data.frame(t = rep(seq(0,60, length.out = 1000), times = 2),
           obs = c(r1,r2),
           valor_r = rep(c("0.1","0.3"), each = 1000)) |> 
  ggplot() + 
  geom_line(aes(x = t, y = obs, color = valor_r)) +
  scale_y_continuous(breaks = seq(23,37,by=2), limits = c(23,37)) +
  scale_x_continuous(breaks = seq(0,24,by=2), limits = c(0,24)) +
  labs(x = "Tiempo (horas)", color = "r", y = "Temperatura corporal (ºC)")


```

Al ser su primer caso oficial, Guido se sintió un poco desconcertado por no saber a qué hora podría haber ocurrido la tragedia. Es por esto que pasó días y días investigando (sin dormir) cuanto tiempo tarda en enfriarse un cuerpo luego de que la persona muera. Finalmente, encontro lo que buscaba, una publicación de [La Gaceta Internacional de Ciencias Forenses](https://www.uv.es/gicf/3R1_Pen%CC%83a_GICF_31.pdf), en la cuál se detalla que, la tasa de enfriamiento del cuerpo varía en tres estapas, las primeras 3 o 4 horas donde la temperatura baja menos de medio grado por hora, las siguientes 6 a 10 horas donde la temperatura baja alrededor de 1 grado por hora, y a partir de las 10 horas el cuerpo desciende su temperatura entre 3/4 a 1/4 grados por hora, hasta alcanzar la temperatura ambiente. Teniendo en cuenta que r se supone constante, se puede asumir que un buen valor de r es mayor que 0,1 y menor que 0,45.

Con el objetivo de finalmente, después de tanto esfuerzo, estimar la hora de la muerte de Sergio, Guido decide utilizar un enfoque Bayesiano, planteando el siguiente modelo lineal.

$$
T(t) - T_{\text{amb}} = T_{\text{diff}} e^{-rt} \Rightarrow \\ ln(T(t) - T_{\text{amb}}) = ln(T_{\text{diff}} e^{-rt}) = \underbrace{ln(T_{\text{diff}})}_{\beta_0} - \underbrace{r}_{\beta_1}t = \beta_0 + \beta_1 \cdot t
$$

Donde $\beta_0$ representa el logaritmo natural de la diferencia entre la temperatura inicial del cuerpo y la temperatura ambiente y $\beta_1$ es el cambio esperado en el logaritmo de la diferencia de temperaturas por cada hora.

Una transformación posible para este modelo, la cuál permite interpretar a $t$ como el tiempo después de haber encontrado el cuerpo, se obtiene mediante una traslación utilizando un nuevo parámetro $\delta$. Resultando:

$$
T(t+\delta) - T_{\text{amb}} = T_{\text{diff}} e^{-r(t+\delta)} \Rightarrow \\ 
ln(T(t+\delta) - T_{\text{amb}}) = ln(T_{\text{diff}} e^{-r(t+\delta)}) = \\ 
\underbrace{ln(T_{\text{diff}})}_{\beta_0} - \underbrace{r}_{\beta_1}(t+\delta) = \beta_0 - \beta_1 \cdot (t+\delta)
$$
El modelo que se usa para estimar la hora de muerte de Sergio resulta entonces:

$$
ln(T(t+\delta) - T_{\text{amb}}) = \beta_0 - \beta_1 \cdot (t+\delta) \ \ \ \ (1)
$$

Donde:

-   $\delta$ es el tiempo (en horas) que transcurrió entre la que persona murió y se encontró el cuerpo.

-   Los demás parámetros conservan su significado.

Guido recuerda haber mirado el pronóstico del tiempo el día de la muerte de Sergio y recuerda que anunciaban una temperatura ambiente de 22 ºC. Por otro lado, dado que la temperatura corporal de una persona sana ronda los 37 °C, consideró esta la temperatura inicial del cuerpo de Sergio. 


$$
ln(T(0)-T_{amb}) = \beta_0 - \beta_1 \cdot (0) \\
\beta_0 = ln(37-22) =ln(15)=  2.7081
$$

Al ser un enfoque bayesiano, Guido debe pensar una distribución a priori para los parámetros $\delta$ y $\beta_1$.

En principio, dado que el cuerpo fue encontrado con una temperatura corporal de 32.8 °C, y sabiendo que Sergio murió desangrado, lo cual acelera considerablemente el descenso de la temperatura, cree que debe haber muerto hace aproximadamente 2 horas, aunque no está para nada seguro, por lo que utilizará una distribución uniforme, que irá entre 1 hora y media y 2 horas y media. 

Con respecto al parámetro $\beta_1$, y considerando la hora a la que estima que murió Sergio y la temperatura a la que fue encontrado, observa lo siguiente.

```{r}
r1 <- function_T(t = seq(0,60, length.out = 1000),
           t_amb = 22,
           t_ini = 37,
           r = 0.1375)

r2 <- function_T(t = seq(0,60, length.out = 1000),
           t_amb = 22,
           t_ini = 37,
           r = 0.16)

r4 <- function_T(t = seq(0,60, length.out = 1000),
           t_amb = 22,
           t_ini = 37,
           r = 0.1825)

```


```{r}
#| fig-cap: "Temperatura del cuerpo según tiempo post-mortem\nTemperatura ambiente: 22 °C"
data.frame(t = rep(seq(0,60, length.out = 1000), times = 3),
           obs = c(r1,r2,r4),
           valor_r = rep(c("r = 0.14", "r = 0.16","r = 0.18"), each = 1000)) |> 
  ggplot() + 
  geom_line(aes(x = t, y = obs, color = valor_r)) +
  scale_y_continuous(breaks = seq(23,37,by=2), limits = c(23,37)) +
  scale_x_continuous(breaks = seq(0,10,by=2), limits = c(0,10)) +
  labs(x = "Tiempo (horas)", color = "r", y = "Temperatura corporal (ºC)")+
  geom_hline(yintercept = 32.8, linetype = "dashed")+
  # geom_vline(xintercept = 0.5) +
  geom_vline(xintercept = 2, linetype = "dashed")
```

En base a esto, tomará valores similares a los graficados para la distribución de $\beta_1$, considerando una distribución normal.

Con respecto al parámetro $\sigma$, cree que un termómetro puede fallar a lo sumo en 2 °C, por lo que postula una distribución media normal, dado que $\sigma$ no puede tomar valores negativos con desvío 0.2. 

De manera un poco más formal, el modelo planteado por Guido es el siguiente, suponiendo que los parámetros, a priori, son independientes.

$$
ln(Y)/\mu_i,\ \sigma \sim N(\mu_i,\ \sigma) \\ 
\mu_i=\beta_0 + \beta_1\cdot (t+\delta) \\ 
\beta_0 =2.7081 \\ 
\beta_1 \sim N^+(0.16,\ 0.075) \\ 
\delta \sim U(1.5, \ 2.5) \\ 
\sigma \sim N^+(0,\ 0.2 )
$$


El interés se centra principalmente en el parámetro $\delta$

# Resultados

El objetivo de Guido es estimar la hora de la muerte y para hacerlo usará toda la información que tenga a su disposición. Pero antes de esto, quiere asegurarse de que sus creencias iniciales tengan sentido, por lo que decide realizar pruebas predictivas a priori.

## Pruebas predictivas a priori

```{r}
load(file = "Stan_models/Resultados_modelos.RData")

datos <- data.frame(
  t = c(0,1.5, 6.75),
  diff = c(10.8,8.5, 1.7)
)

n <- 40000
largo_grilla <- 100

grilla_t <- seq(-4, 7 ,length.out = largo_grilla)

beta_0 <- 2.7081
pred_prior <- data.frame(
  beta1 = abs(rnorm(n, 0.16, 0.02)),
  d = abs(runif(n, min = 1.5, max = 2.5)),
  sigma = abs(rnorm(n,0,0.05))
  ) 

# 
# calc_diff_prom <- function(t, data) {
#   return(beta_0 - data$beta1 * (t+data$d))
# }
# 
# 
# diff_prom <- sapply(grilla_t, calc_diff_prom, pred_prior) |> `colnames<-`(round(grilla_t,1))
# 
# graf <- as.data.frame(diff_prom)

# Grafico con intervalo de credibilidad ------------
calc_pred_linear <- function(t, data) {
  return((2.7081 - data$beta1 * (t+data$d)))
}

pred_linear <- sapply(grilla_t, calc_pred_linear, pred_prior) |> `colnames<-`(round(grilla_t,1))

pred_linear <- as.data.frame(pred_linear)


mu_mean <- apply(pred_linear, 2, mean)

mu_qts <- t(apply(pred_linear, 2, function(x) quantile(x, c(0.025, 0.975))))

mu_qts2 <- t(apply(pred_linear, 2, function(x) quantile(x, c(0.25, 0.75))))


data_mu_pred <- data.frame(
  t = grilla_t, 
  y = mu_mean,
  lower_95 = mu_qts[, 1],
  upper_95 = mu_qts[, 2],
  lower_50 = mu_qts2[, 1],
  upper_50 = mu_qts2[, 2]
)

calc_diff_prom_prior <- function(t, data) {
  return(exp(rnorm(nrow(data), mean = (2.7081 - data$beta1 * (t+data$d)), sd = data$sigma)))
}

diff_prom_pred <- sapply(grilla_t, calc_diff_prom_prior, pred_prior) |> `colnames<-`(round(grilla_t,1))

graf_pred <- as.data.frame(diff_prom_pred)

y_mean <- apply(graf_pred, 2, mean)

y_qts <- t(apply(graf_pred, 2, function(x) quantile(x, c(0.025, 0.975))))

y_qts2 <- t(apply(graf_pred, 2, function(x) quantile(x, c(0.25, 0.75))))


data_y_pred <- data.frame(
  t = grilla_t, 
  y = y_mean,
  lower_95 = y_qts[, 1],
  upper_95 = y_qts[, 2],
  lower_50 = y_qts2[, 1],
  upper_50 = y_qts2[, 2]
)
```


```{r}
#| label: fig-bandas-prior
#| fig-cap: "Distribución a Priori"
#| fig-subcap: 
#|   - "Del predictor lineal"
#|   - "De $T(t)-T_{amb}$"
#| layout-ncol: 2


ggplot(data_mu_pred) +
  geom_ribbon(
    aes(t, ymin = lower_95, ymax = upper_95),
    fill = "grey50",
    alpha = 0.6
  ) +
  geom_ribbon(
    aes(t, ymin = lower_50, ymax = upper_50),
    fill = "grey35",
    alpha = 0.6
  ) +
  geom_line(
    aes(t, y), 
    color = "firebrick"
  ) + 
  labs(x = "Tiempo", y = expression(mu[i])) +
  scale_x_continuous(breaks = seq(-4,7,1), limits = c(-4,7))
  
ggplot(data_y_pred) +
  geom_ribbon(
    aes(t, ymin = lower_95, ymax = upper_95),
    fill = "grey50",
    alpha = 0.6) +
  geom_ribbon(
    aes(t, ymin = lower_50, ymax = upper_50),
    fill = "grey35",
    alpha = 0.6) +
  geom_line(
    aes(t, y), 
    color = "firebrick") +
  # geom_mark_ellipse(
  #   data = datos[1,],
  #   mapping = aes(x = t, y = log(diff)),
  #   label = "Primera observación",
  #   description = "06:45 | 32.8ºC", 
  #   color = "red", 
  #   expand = 0.01) +
  labs(x = "Tiempo", y = expression(T(t)-T[amb])) +
  scale_x_continuous(breaks = seq(-4,7,1), limits = c(-4,7))

```

Sumado a esto decide buscar un intervalo de tiempo en el que pueda decir con un 90% de certeza que Sergio murió dentro de ese rango horario.

```{r}
predictiva_prior <- dec_a_hex(6.75 - quantile(pred_prior$d,probs = c(0.95, 0.05)))

```

A priori Guido concluye con una credibilidad del 90% que sergio murió entre las `r predictiva_prior[1]` y las `r predictiva_prior[2]`, por lo que las distribuciones a priori que planteó parecen tener sentido.

## Pruebas predictivas a Posteriori

Ahora sí, finalmente Guido utilizará los datos provistos para estimar la hora de la muerte, pero con el objetivo de desafiarse a sí mismo decide hacerlo de manera secuencial, para ver como los datos van afectando sus estimaciones.

Después de que la computadora de bajos recursos del departamento de la Policía Científica estuviera encendida durante días, Guido consiguió los siguientes resultados.

Los datos disponibles son los siguientes:

```{r}
datos |> 
  mutate(log_diff = round(log(diff), 3)) |> 
  `colnames<-`(c("$Tiempo$", "$Temp_{diff}$", "$ln(Temp_{diff})$")) |>
  knitr::kable(format = "pipe")
```


```{r prediccion 7am}
stan_data <- list(
    N = nrow(datos[1,]), 
    t = as.array(datos[1,]$t),     
    y = as.array(log(datos[1,]$diff))      
)

```


```{r, eval=FALSE}
stan_model <- stan(
    file = "Stan_models/Model_1.stan",
    chains = 4,
    data = stan_data,
    iter = 10000,
    refresh = 0,
    seed = 90502
    )
```

A Guido le remarcaban mucho en clases de Estadística Bayesiana la importancia de verificar la convergencia de las cadenas de Markov, en este caso obtenidas por el método NUTS (_No-U-Turn Sampler_), para los distintos párametros del modelo. Es por ello que para cada una de las estimaciones de los parámetros, presenta gráficos de densidad y de traza.

```{r}
source("Graficos.R")
df_posterior <- as.data.frame(extract(stan_model))
colores <- c("skyblue2", "gray34", "lightgreen", "pink")
```

\newpage

```{r graficos cadenas 1}
#| label: fig-cadenas1
#| fig-cap: "Cadenas de Markov para $\\beta_1$"
#| fig-subcap: 
#|   - "Traza"
#|   - "Densidad"
#| layout-ncol: 2

trace_plot(df_posterior, 1, colores)

density_plot(df_posterior, 1,  colores)
```

```{r graficos cadenas 2}
#| label: fig-cadenas2
#| fig-cap: "Cadenas de Markov para $\\delta$"
#| fig-subcap: 
#|   - "Traza"
#|   - "Densidad"
#| layout-ncol: 2

trace_plot(df_posterior, 2, colores)

density_plot(df_posterior, 2,  colores)
```


Con la información provista hasta las 7 de la mañana las cadenas de markov para cada uno de los parametros parecen converger a la misma distribucion a posteriori. Esto, además de haber obtenido un $\hat R = 1$ para todos los párametros le confirman a Guido que las muestras obtenidas son representativas.


La curiosidad de Guido lo llevaba a querer visualizar como los datos afectan al prior, por lo que graficó bandas de credibilidad para el predictor lineal y para la diferencias de temperaturas.

```{r}

calc_pred_linear <- function(t, data) {
  return((2.7081 - data$beta1 * (t+data$d)))
}

pred_linear <- sapply(grilla_t, calc_pred_linear, df_posterior) |> `colnames<-`(round(grilla_t,1))

pred_linear <- as.data.frame(pred_linear)



# Grafico con intervalo de credibilidad ------------


mu_mean <- apply(pred_linear, 2, mean)

mu_qts <- t(apply(pred_linear, 2, function(x) quantile(x, c(0.025, 0.975))))

mu_qts2 <- t(apply(pred_linear, 2, function(x) quantile(x, c(0.25, 0.75))))


data_mu <- data.frame(
  t = grilla_t, 
  y = mu_mean,
  lower_95 = mu_qts[, 1],
  upper_95 = mu_qts[, 2],
  lower_50 = mu_qts2[, 1],
  upper_50 = mu_qts2[, 2]
)
```


```{r prediccion 7am 2}
# Bandas

calc_diff_prom_posterior <- function(t, data) {
  return(exp(rnorm(nrow(data), mean = (2.7081 - data$beta1 * (t+data$d)), sd = data$sigma)))
}

diff_prom_2 <- sapply(grilla_t, calc_diff_prom_posterior, df_posterior) |> `colnames<-`(round(grilla_t,1))

graf_2 <- as.data.frame(diff_prom_2)



# Grafico con intervalo de credibilidad ------------


y_mean <- apply(graf_2, 2, mean)

y_qts <- t(apply(graf_2, 2, function(x) quantile(x, c(0.025, 0.975))))

y_qts2 <- t(apply(graf_2, 2, function(x) quantile(x, c(0.25, 0.75))))


data_y <- data.frame(
  t = grilla_t, 
  y = y_mean,
  lower_95 = y_qts[, 1],
  upper_95 = y_qts[, 2],
  lower_50 = y_qts2[, 1],
  upper_50 = y_qts2[, 2]
)
```


```{r graf prediccion 7am 2}
#| label: fig-bandas1
#| fig-cap: "Distribuciónes a Priori con la información hasta las 7hs"
#| fig-subcap: 
#|   - "Del predictor lineal"
#|   - "De $T(t)-T_{amb}$"
#| layout-ncol: 2

ggplot(data_mu) +
  geom_ribbon(
    aes(t, ymin = lower_95, ymax = upper_95),
    fill = "grey50",
    alpha = 0.6) +
  geom_ribbon(
    aes(t, ymin = lower_50, ymax = upper_50),
    fill = "grey35",
    alpha = 0.6) +
  geom_line(
    aes(t, y), 
    color = "firebrick") + 
  geom_point(
    data = datos[1,],mapping = aes(x = t, y = log(diff)), size = 1) +
  # geom_mark_ellipse(
  #   data = datos[1,],
  #   mapping = aes(x = t, y = log(diff)),
  #   label = "Primera observación",
  #   description = "06:45 | 32.8ºC", 
  #   color = "red", 
  #   expand = 0.01) +
  labs(x = "Tiempo", y = expression(mu[i])) +
  scale_x_continuous(breaks = seq(-4,7,1), limits = c(-4,7))


ggplot(data_y) +
  geom_ribbon(
    aes(t, ymin = lower_95, ymax = upper_95),
    fill = "grey50",
    alpha = 0.6) +
  geom_ribbon(
    aes(t, ymin = lower_50, ymax = upper_50),
    fill = "grey35",
    alpha = 0.6) +
  geom_line(
    aes(t, y), 
    color = "firebrick") +
  geom_point(
    data = datos[1,],mapping = aes(x = t, y = diff), size = 1) +
  # geom_mark_ellipse(
  #   data = datos[1,],
  #   mapping = aes(x = t, y = log(diff)),
  #   label = "Primera observación",
  #   description = "06:45 | 32.8ºC", 
  #   color = "red", 
  #   expand = 0.01) +
  labs(x = "Tiempo", y = expression(T(t)-T[amb])) +
  scale_x_continuous(breaks = seq(-4,7,1), limits = c(-4,7))



```

```{r}
predictiva_post1 <- dec_a_hex(6.75 - quantile(df_posterior$d,probs = c(0.95, 0.05)))
```


Guido observa que esta primera observación parece acotar levemente el intervalo de tiempo en el que puede decir con una buena certeza que Sergio murió. Ahora Guido puede decir con la misma credibilidad de antes que Sergio falleció entre las `r predictiva_post1[1]` y las `r predictiva_post1[2]`. Esto no parece mucho, pero le sirve a Guido para saber que va por buen camino, lo cual lo motiva a seguir.

Guido procede a seguir añadiendo datos a su modelo, con lo que usa la información disponible hasta las 10hs obteniendo los siguientes resultados. 

```{r prediccion 10am 1, eval=FALSE}
stan_data_2 <- list(
    N = nrow(datos[1:2,]), 
    t = datos[1:2,]$t,     
    y = log(datos[1:2,]$diff)      
)

stan_model_2 <- stan(
    file = "Stan_models/Model_1.stan",
    chains = 4,
    data = stan_data_2,
    iter = 10000,
    refresh = 0,
    seed = 110701
)
```


```{r}
mcmc_trace(stan_model_2)
mcmc_dens_overlay(stan_model_2)

df_posterior_2 <- as.data.frame(extract(stan_model_2))

```

De igual forma que con un solo dato, las cadenas convergen a la misma distribución para todos los parámetros, pero estas son incluso más acotadas que antes.

```{r prediccion 10am 2}
# Grafico con intervalo de credibilidad

pred_linear2 <- sapply(grilla_t, calc_pred_linear, df_posterior_2) |> `colnames<-`(round(grilla_t,1))

pred_linear2 <- as.data.frame(pred_linear2)



mu_mean <- apply(pred_linear2, 2, mean)

mu_qts <- t(apply(pred_linear2, 2, function(x) quantile(x, c(0.025, 0.975))))

mu_qts2 <- t(apply(pred_linear2, 2, function(x) quantile(x, c(0.25, 0.75))))


data_mu2 <- data.frame(
  t = grilla_t, 
  y = mu_mean,
  lower_95 = mu_qts[, 1],
  upper_95 = mu_qts[, 2],
  lower_50 = mu_qts2[, 1],
  upper_50 = mu_qts2[, 2]
)

# Grafico con intervalo de credibilidad

diff_prom_3 <- sapply(grilla_t, calc_diff_prom_posterior, df_posterior_2) |> `colnames<-`(round(grilla_t,1))

graf_3 <- as.data.frame(diff_prom_3)



y_mean <- apply(graf_3, 2, mean)

y_qts <- t(apply(graf_3, 2, function(x) quantile(x, c(0.025, 0.975))))

y_qts2 <- t(apply(graf_3, 2, function(x) quantile(x, c(0.25, 0.75))))


data_y2 <- data.frame(
  t = grilla_t, 
  y = y_mean,
  lower_95 = y_qts[, 1],
  upper_95 = y_qts[, 2],
  lower_50 = y_qts2[, 1],
  upper_50 = y_qts2[, 2]
)


```


```{r}
#| label: fig-bandas2
#| fig-cap: "Distribuciónes a Priori con la información hasta las 10hs"
#| fig-subcap: 
#|   - "Del predictor lineal"
#|   - "De $T(t)-T_{amb}$"
#| layout-ncol: 2

ggplot(data_mu2) +
  geom_ribbon(
    aes(t, ymin = lower_95, ymax = upper_95),
    fill = "grey50",
    alpha = 0.6) +
  geom_ribbon(
    aes(t, ymin = lower_50, ymax = upper_50),
    fill = "grey35",
    alpha = 0.6) +
  geom_line(
    aes(t, y), 
    color = "firebrick") + 
  geom_point(
    data = datos[1:2,],mapping = aes(x = t, y = log(diff)), size = 1) +
  # geom_mark_ellipse(
  #   data = datos[1,],
  #   mapping = aes(x = t, y = log(diff)),
  #   label = "Primera observación",
  #   description = "06:45 | 32.8ºC", 
  #   color = "red", 
  #   expand = 0.01) +
  labs(x = "Tiempo", y = expression(mu[i])) +
  scale_x_continuous(breaks = seq(-4,7,1), limits = c(-4,7))


ggplot(data_y2) +
  geom_ribbon(
    aes(t, ymin = lower_95, ymax = upper_95),
    fill = "grey50",
    alpha = 0.6) +
  geom_ribbon(
    aes(t, ymin = lower_50, ymax = upper_50),
    fill = "grey35",
    alpha = 0.6) +
  geom_line(
    aes(t, y), 
    color = "firebrick") + 
  geom_point(
    data = datos[1:2,],mapping = aes(x = t, y = diff), size = 1) +
  # geom_mark_ellipse(
  #   data = datos[1,],
  #   mapping = aes(x = t, y = log(diff)),
  #   label = "Primera observación",
  #   description = "06:45 | 32.8ºC", 
  #   color = "red", 
  #   expand = 0.01) +
  labs(x = "Tiempo", y = expression(T(t)-T[amb])) +
  scale_x_continuous(breaks = seq(-4,7,1), limits = c(-4,7))

```

```{r}
predictiva_post2 <- dec_a_hex(6.75 - quantile(df_posterior_2$d,probs = c(0.95, 0.05)))
```


Guido ahora concluye con una certeza del 90% que Sergio pereció entre las `r predictiva_post2[1]` y las `r predictiva_post2[2]`.

Finalmente, decide hacer uso de toda la información disponible, aunque la última temperatura registrada del cuerpo le traía un mal presentimiento...

```{r prediccion todos los datos 1}
stan_data_3 <- list(
    N = nrow(datos), 
    t = datos$t,     
    y = log(datos$diff)      
)
```

```{r, eval=FALSE}
stan_model_3 <- stan(
    file = "Stan_models/Model_1.stan",
    chains = 4,
    data = stan_data_3,
    iter = 10000,
    refresh = 0,
    seed = 90502
)
# save(stan_model,stan_model_2,stan_model_3,file = "Stan_models/Resultados_modelos.RData")
```


```{r}
mcmc_dens_overlay(stan_model_3)

mcmc_trace(stan_model_3)

df_posterior_3 <- as.data.frame(extract(stan_model_3))

```

Hasta ahora todo iba bien, las cadenas aún convergían, pero al ver la densidad estimada del parámetro $\delta$ sospechaba que algo no encajaba, pero decidió seguir adelante.

```{r prediccion 10am 3}
# Grafico con intervalo de credibilidad

pred_linear3 <- sapply(grilla_t, calc_pred_linear, df_posterior_3) |> `colnames<-`(round(grilla_t,1))

pred_linear3 <- as.data.frame(pred_linear3)



mu_mean <- apply(pred_linear3, 2, mean)

mu_qts <- t(apply(pred_linear3, 2, function(x) quantile(x, c(0.025, 0.975))))

mu_qts2 <- t(apply(pred_linear3, 2, function(x) quantile(x, c(0.25, 0.75))))


data_mu3 <- data.frame(
  t = grilla_t, 
  y = mu_mean,
  lower_95 = mu_qts[, 1],
  upper_95 = mu_qts[, 2],
  lower_50 = mu_qts2[, 1],
  upper_50 = mu_qts2[, 2]
)

# Grafico con intervalo de credibilidad

diff_prom_4 <- sapply(grilla_t, calc_diff_prom_posterior, df_posterior_3) |> `colnames<-`(round(grilla_t,1))

graf_4 <- as.data.frame(diff_prom_4)



y_mean <- apply(graf_4, 2, mean)

y_qts <- t(apply(graf_4, 2, function(x) quantile(x, c(0.025, 0.975))))

y_qts2 <- t(apply(graf_4, 2, function(x) quantile(x, c(0.25, 0.75))))


data_y3 <- data.frame(
  t = grilla_t, 
  y = y_mean,
  lower_95 = y_qts[, 1],
  upper_95 = y_qts[, 2],
  lower_50 = y_qts2[, 1],
  upper_50 = y_qts2[, 2]
)


```


```{r}
#| label: fig-bandas3
#| fig-cap: "Distribuciónes a Priori con toda la información disponible"
#| fig-subcap: 
#|   - "Del predictor lineal"
#|   - "De $T(t)-T_{amb}$"
#| layout-ncol: 2

ggplot(data_mu3) +
  geom_ribbon(
    aes(t, ymin = lower_95, ymax = upper_95),
    fill = "grey50",
    alpha = 0.6) +
  geom_ribbon(
    aes(t, ymin = lower_50, ymax = upper_50),
    fill = "grey35",
    alpha = 0.6) +
  geom_line(
    aes(t, y), 
    color = "firebrick") + 
  geom_point(
    data = datos,mapping = aes(x = t, y = log(diff)), size = 1) +
  # geom_mark_ellipse(
  #   data = datos[1,],
  #   mapping = aes(x = t, y = log(diff)),
  #   label = "Primera observación",
  #   description = "06:45 | 32.8ºC", 
  #   color = "red", 
  #   expand = 0.01) +
  labs(x = "Tiempo", y = expression(mu[i])) +
  scale_x_continuous(breaks = seq(-4,7,1), limits = c(-4,7))


ggplot(data_y3) +
  geom_ribbon(
    aes(t, ymin = lower_95, ymax = upper_95),
    fill = "grey50",
    alpha = 0.6) +
  geom_ribbon(
    aes(t, ymin = lower_50, ymax = upper_50),
    fill = "grey35",
    alpha = 0.6) +
  geom_line(
    aes(t, y), 
    color = "firebrick") + 
    geom_point(
    data = datos,mapping = aes(x = t, y = diff), size = 1) +
  # geom_mark_ellipse(
  #   data = datos[1,],
  #   mapping = aes(x = t, y = log(diff)),
  #   label = "Primera observación",
  #   description = "06:45 | 32.8ºC", 
  #   color = "red", 
  #   expand = 0.01) +
  labs(x = "Tiempo", y = expression(T(t)-T[amb])) +
  scale_x_continuous(breaks = seq(-4,7,1), limits = c(-4,7))

```

```{r}
predictiva_post3 <- dec_a_hex(6.75 - quantile(df_posterior_3$d,probs = c(0.95, 0.05)))
```

Con estos resultados, Sergio pudo haber fenecido entre las `r predictiva_post3[1]` y las `r predictiva_post3[2]`, un intervalo de tiempo mayor que el que se había obtenido anteriormente.

"¡Lo que sospechaba!" dijo Guido, al asimilar que la última temperatura registrada de Sergio fue en la morgue, un lugar que tiende a ser frío para la preservación de los cadáveres, con lo que la temperatura del cuerpo de Sergio pudo haberse enfriado más rapidamente que en el lugar del hecho, donde recuerda que había una temperatura ambiente de 22 ºC.

Pero esto no era todo, Guido pensó, ¿Qué hubiera pasado si Sergio no gozaba de un buen estado de salud?. Por lo que si tuviese información que indique que Sergio no gozaba de buena salud al momento de fallecer, esto podría modificar su creencia a Priori ya que la velocidad de enfriamiento se retarda en casos de enfermedades febriles, personas con obesidad e intoxicaciones por nicotina, rodenticidas, entre otros. También la perdida de calor del cuerpo puede acelerarse en personas con bajo peso, enfermedades crónicas e intoxicadas por fósforo, arsénico y alcohol^[[La Gaceta Internacional de Ciencias Forenses](https://www.uv.es/gicf/3R1_Pen%CC%83a_GICF_31.pdf)].

Una posible solución que pensó, podría ser agregar una variable que indique si la persona gozaba de un buen estado de salud, junto a un parámetro $\beta_2$ que modifique la pendiente original. Resultando el modelo:

$$ln(T(t) - T_{amb}) = \underbrace{ln(T_{\text{diff}})}_{\beta_0} - \underbrace{r}_{\beta_1} \cdot (t + \delta) + \beta_2 \cdot I \cdot (t + \delta)= \beta_0 - \beta_1 \cdot (t + \delta) + \beta_2 \cdot I \cdot (t + \delta) = \beta_0 + (\beta_2 \cdot I - \beta_1) \cdot (t + \delta)$$
Donde:

- Las interpretaciones de $\beta_0$, $\beta_1$ y $\delta$ son las mismas que el modelo $(1)$.

- $\beta_2$: es la diferencia entre la tasa de enfriamiento de una persona que goza de un buen estado de salud de la que no lo goza. 

- $I = \left\{\begin{matrix} 0 \ \ \ \text{si Sergio gozaba de un buen estado de salud} \ \ \ \ \ \\ 1 \ \ \ \text{si Sergio no gozaba de un buen estado de salud}  \end{matrix}\right.$


# COSAS A AGREGAR

- Interpretaciones a los gráficos de las bandas de credibilidad

- Graficos de trazas y densidades de parametros




trace plot | densidad (p/c parametro)



